#!/usr/bin/env python3

from googlesearch import search # type: ignore
from smtplib import SMTP, SMTPRecipientsRefused, SMTPSenderRefused, SMTPResponseException
from email.mime.multipart import MIMEMultipart
import re
import os
import time
import socket
import requests
import ipaddress
import readline
import colorama
from colorama import *
from time import sleep
import sys
import json
from PIL import Image
from PIL.ExifTags import TAGS
import piexif
from prompt_toolkit import print_formatted_text, HTML
from pathlib import Path
import platform
from datetime import datetime
import phonenumbers # type: ignore
from phonenumbers import geocoder # type: ignore
import opencage
from bs4 import BeautifulSoup as bs
import tkinter as tk
from tkinter import messagebox
import webbrowser
import stripe # type: ignore
import tkinter as tk
from tkinter import filedialog, simpledialog, messagebox
from PIL import Image, ImageTk
import base64
from googleapiclient.discovery import build # type: ignore
import requests
from bs4 import BeautifulSoup
import webbrowser
from datetime import datetime, timedelta
from flask import Flask, request, render_template_string
import requests
from cryptography.fernet import Fernet # type: ignore
import subprocess
import shutil


##Code Analysis
def run_command(command):
    """Run a command in the shell and return its output."""
    result = subprocess.run(command, shell=True, capture_output=True, text=True)
    return result.stdout.strip(), result.stderr.strip()

def analyze_python_file(file_path):
    """Analyze a Python file for errors using pylint and flake8."""
    print(f"\033[1;93m[+]\033[1;97m Analyzing Python file: {file_path}")
    print("")
    pylint_command = f"pylint {file_path}"
    flake8_command = f"flake8 {file_path}"
    
    pylint_output, pylint_errors = run_command(pylint_command)
    flake8_output, flake8_errors = run_command(flake8_command)
    
    if pylint_errors:
        print(f"\033[1;91m[!]\033[1;97m Pylint errors:\n{pylint_errors}")
        print("")
    else:
        print(f"\033[1;91m[+]\033[1;97m  Pylint output:\n{pylint_output}")
    
    if flake8_errors:
        print(f"\033[1;91m[+]\033[1;97m  Flake8 errors:\n{flake8_errors}")
    else:
        print(f"\033[1;91m[+]\033[1;97m  Flake8 output:\n{flake8_output}")

def analyze_javascript_file(file_path):
    """Analyze a JavaScript file for errors using eslint."""
    print(f"\033[1;91m[+]\033[1;97m Analyzing JavaScript file: {file_path}")
    eslint_command = f"eslint {file_path}"
    
    eslint_output, eslint_errors = run_command(eslint_command)
    
    if eslint_errors:
        print(f"\033[1;91m[+]\033[1;97m ESLint errors:\n{eslint_errors}")
    else:
        print(f"\033[1;91m[+]\033[1;97m ESLint output:\n{eslint_output}")


##Check for updates from GIthub Repo
##Fetchupdates
def get_latest_commit(repo_owner, repo_name):
    url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/commits/master"
    response = requests.get(url)
    response.raise_for_status()
    return response.json()['sha']

def get_local_commit():
    result = subprocess.run(['git', 'rev-parse', 'HEAD'], capture_output=True, text=True)
    return result.stdout.strip()

def update_repo():
    subprocess.run(['git', 'fetch', 'origin'], check=True)
    subprocess.run(['git', 'reset', '--hard', 'origin/master'], check=True)

def copy_to_bin(script_name):
    bin_path = '/usr/local/bin'
    script_path = os.path.join(os.getcwd(), script_name)
    
    target_path = os.path.join(bin_path, script_name)
    if os.path.exists(script_path):
        shutil.copy(script_path, target_path)
      # Ensure the script is executable
        os.chmod(target_path, 0o755)
    else:
        print(f"\033[1;91m[!]\033[1;97m Script {script_name} not found in the current directory.\033[0m")

    
def restart_script():
    python = sys.executable
    os.execl(python, python, *sys.argv)

def check_for_updates(repo_owner, repo_name, script_name):
    try:
        latest_commit = get_latest_commit(repo_owner, repo_name)
        local_commit = get_local_commit()

        if latest_commit != local_commit:
            print("Update available. Updating...")
            update_repo()
            copy_to_bin(script_name)
            restart_script()
        else:
            print("\033[1;91m[+]\033[1;97m Already up-to-date.")
    except requests.RequestException as e:
        print(f"\033[1;91m[!]\033[1;97m Failed to fetch latest commit: {e}")
    except subprocess.CalledProcessError as e:
        print(f"\033[1;91m[!]\033[1;97m Failed to update repo: {e}")


def update_script():
    repo_owner = "TermuxHackz"
    repo_name = "X-Osint"
    script_name = "xosint"

    # Check for updates
    check_for_updates(repo_owner, repo_name, script_name)

    # Your existing script logic here
    print("\033[1;91m[+]\033[1;97m Running main script...")
    time.sleep(0.5)

# Define the ImageSearchApp function
API_KEY_FILE = "api_keys.txt"

def save_api_keys(api_key, search_engine_id):
    with open(API_KEY_FILE, "w") as f:
        f.write(f"{api_key}\n{search_engine_id}")

def load_api_keys():
    if os.path.exists(API_KEY_FILE):
        with open(API_KEY_FILE, "r") as f:
            keys = f.read().splitlines()
            if len(keys) == 2:
                return keys[0], keys[1]
    return None, None

def image_hunt():
    root = tk.Tk()
    root.title("Reverse Image Search")

    # Add title label
    title_label = tk.Label(root, text="Reverse Image Search", font=("Arial", 18, "bold"))
    title_label.pack(pady=10)

    # Ask user if they want to watch a demo
    response = messagebox.askquestion("Demo", "Kindly watch a video on how to get your API keys?")
    if response == 'yes':
        # Open YouTube video in web browser
        webbrowser.open("https://youtu.be/g2WU0aFExMM")

    # Add upload button
    upload_button = tk.Button(root, text="Upload Image", command=lambda: upload_image(root), font=("Arial", 12, "bold"))
    upload_button.pack(pady=20)

    # Add image label
    global image_label
    image_label = tk.Label(root)
    image_label.pack(pady=10)

    # Add result label
    global result_label
    result_label = tk.Label(root, text="")
    result_label.pack(pady=10)

    root.protocol("WM_DELETE_WINDOW", lambda: on_closing(root))
    root.mainloop()

def upload_image(root):
    api_key, search_engine_id = load_api_keys()

    if not api_key or not search_engine_id:
        api_key = simpledialog.askstring("API Key", "Enter your Google Custom Search API Key:")
        search_engine_id = simpledialog.askstring("Search Engine ID", "Enter your Google Custom Search Engine ID:")

        if api_key and search_engine_id:
            save_api_keys(api_key, search_engine_id)
        else:
            messagebox.showerror("Error", "API key and Search Engine ID are required.")
            return

    file_path = filedialog.askopenfilename(filetypes=[("Image files", "*.jpg *.png")])
    if file_path:
        try:
            image = Image.open(file_path)
            image = image.resize((400, 400), Image.LANCZOS)
            photo = ImageTk.PhotoImage(image)

            image_label.config(image=photo)
            image_label.image = photo  # Keep a reference to avoid garbage collection

            google_results = reverse_image_search_google(api_key, search_engine_id, file_path)
            show_results(google_results)
        except Exception as e:
            messagebox.showerror("Error", str(e))

def reverse_image_search_google(api_key, search_engine_id, image_path):
    service = build("customsearch", "v1", developerKey=api_key)
    with open(image_path, "rb") as image_file:
        image_content = base64.b64encode(image_file.read()).decode('utf-8')

    search_response = service.cse().list(
        q='',
        cx=search_engine_id,
        searchType='image',
        num=10
    ).execute()

    results = []
    if 'items' in search_response:
        for item in search_response['items']:
            results.append(item['link'])

    return results

def show_results(google_results):
    if google_results:
        google_text = "Google Search Results:\n" + "\n".join(google_results[:5])
    else:
        google_text = "No Google search results found."

    result_label.config(text=google_text)

def on_closing(root):
    root.destroy()
    exit()


###Add News OSint script here
def get_news_articles(query, api_key):
    url = f'https://newsapi.org/v2/everything?q={query}&apiKey={api_key}'
    response = requests.get(url)
    if response.status_code == 200:
        return response.json()['articles']
    else:
        print(f"Error: {response.status_code}")
        return []

def newsOsint():
    api_key = 'a701b803d0ac4fc89aaded6143de644d'
    
    # Prompt the user to input a name
    name = input("\033[1;91m[+]\033[1;97mEnter the name you want to search for: \033[0m")
    
    # Fetch news articles related to the input name
    articles = get_news_articles(name, api_key)
    
    # Display the articles
    if articles:
        print(f"\nNews articles about {name}:\n")
        for i, article in enumerate(articles, start=1):
            print(f"{i}. {article['title']}")
            print(f"   Source: {article['source']['name']}")
            print("")
            print(f"   Link: {article['url']}\n")
    else:
        print("No articles found.")


###Phone number Location
def get_api_keys():
    if os.path.exists('numandcage_keys.txt'):
        with open('numandcage_keys.txt', 'r') as file:
            keys = file.readlines()
            if len(keys) == 4:
                ipqualityscore_api_key = keys[0].strip()
                opencage_api_key = keys[1].strip()
                vonage_api_key = keys[2].strip()
                vonage_api_secret = keys[3].strip()
            else:
                ipqualityscore_api_key, opencage_api_key, vonage_api_key, vonage_api_secret = get_and_save_api_keys()
    else:
        ipqualityscore_api_key, opencage_api_key, vonage_api_key, vonage_api_secret = get_and_save_api_keys()
    
    return ipqualityscore_api_key, opencage_api_key, vonage_api_key, vonage_api_secret

def get_and_save_api_keys():
    while True:
        ipqualityscore_api_key = input("\033[1;91m[\033[1;33;40m*\033[0m\033[1;91m] \033[1;97m Enter your IPQualityScore API key: \033[0m").strip()
        opencage_api_key = input("\033[1;91m[\033[1;33;40m*\033[0m\033[1;91m] \033[1;97m Enter your OpenCage API key: \033[0m").strip()
        vonage_api_key = input("\033[1;91m[\033[1;33;40m*\033[0m\033[1;91m] \033[1;97m Enter your Vonage API key: \033[0m").strip()
        vonage_api_secret = input("\033[1;91m[\033[1;33;40m*\033[0m\033[1;91m] \033[1;97m Enter your Vonage API secret: \033[0m").strip()
        if ipqualityscore_api_key and opencage_api_key and vonage_api_key and vonage_api_secret:
            with open('numandcage_keys.txt', 'w') as file:
                file.write(f"{ipqualityscore_api_key}\n{opencage_api_key}\n{vonage_api_key}\n{vonage_api_secret}")
            return ipqualityscore_api_key, opencage_api_key, vonage_api_key, vonage_api_secret
        else:
            print("\033[1;91m[\033[1;33;40m!\033[0m\033[1;91m] \033[1;97m Please enter valid API keys. \033[0m")

def get_phone_info(phone_number, ipqualityscore_api_key, vonage_api_key, vonage_api_secret):
    ipqualityscore_url = f"https://ipqualityscore.com/api/json/phone/{ipqualityscore_api_key}/{phone_number}"
    response = requests.get(ipqualityscore_url)
    ipqualityscore_info = response.json()

    vonage_url = f"https://api.nexmo.com/ni/advanced/async/json"
    vonage_params = {
        'api_key': vonage_api_key,
        'api_secret': vonage_api_secret,
        'number': phone_number
    }
    response = requests.get(vonage_url, params=vonage_params)
    vonage_info = response.json()

    phone_info = {**ipqualityscore_info, **vonage_info}  # Merge dictionaries
    return phone_info



def get_location_info(country_code, location, opencage_api_key):
    opencage_url = f"https://api.opencagedata.com/geocode/v1/json?q={location}&countrycode={country_code}&key={opencage_api_key}"
    response = requests.get(opencage_url)
    return response.json()

def is_valid_phone_number(phone_number):
    # Basic validation to check if phone number includes a country code and is numeric
    if phone_number.startswith('+') and phone_number[1:].isdigit():
        return True
    return False

def open_in_maps(latitude, longitude):
    choice = input("\033[1;91m[\033[1;33;40m*\033[0m\033[1;91m] \033[1;97m Would you like to open the location in Google Maps or Apple Maps? (Enter 'google' or 'apple'): \033[0m").strip().lower()
    if choice == 'google':
        webbrowser.open(f"https://www.google.com/maps/search/?api=1&query={latitude},{longitude}")
    elif choice == 'apple':
        webbrowser.open(f"https://maps.apple.com/?q={latitude},{longitude}")
    else:
        print("Invalid choice. Skipping map opening.")

def phone_inf():
    ipqualityscore_api_key, opencage_api_key, vonage_api_key, vonage_api_secret = get_api_keys()

    while True:
        print("")
        phone_number = input("\033[1;91m[\033[1;33;40m+\033[0m\033[1;91m] \033[1;93m Enter the phone number (with country code, e.g., +1234567890): \033[0m").strip()
        if is_valid_phone_number(phone_number):
            break
        else:
            print("\033[1;91m[\033[1;33;40m!\033[0m\033[1;91m] \033[1;97mPlease enter a valid phone number with country code.")

    phone_info = get_phone_info(phone_number, ipqualityscore_api_key, vonage_api_key, vonage_api_secret)

    if phone_info.get('valid', False):
        print("")
        print(f"\033[1;91m➤\033[1;97mPhone Number      : {phone_info.get('phone_number', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mCountry           : {phone_info.get('country', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mLocation          : {phone_info.get('location', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mCarrier           : {phone_info.get('carrier', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mLine Type         : {phone_info.get('line_type', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mRisk Score        : {phone_info.get('risk_score', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mSpammer           : {phone_info.get('spammer', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mActive            : {phone_info.get('active', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mRecent Abuse      : {phone_info.get('recent_abuse', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mFraud Score       : {phone_info.get('fraud_score', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mPorted            : {phone_info.get('ported', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mCaller Type       : {phone_info.get('caller_type', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mCaller Name       : {phone_info.get('caller_name', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mRoaming           : {phone_info.get('roaming', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mReachable         : {phone_info.get('reachable', 'N/A')}")
        print("")
        print(f"\033[1;91m➤\033[1;97mHandset Status    : {phone_info.get('handset_status', 'N/A')}")
        print("")

        if phone_info.get('country_code', False) and phone_info.get('location', False):
            location_info = get_location_info(phone_info['country_code'], phone_info['location'], opencage_api_key)
            if location_info['results']:
                location = location_info['results'][0]['geometry']
                latitude = location['lat']
                longitude = location['lng']
                print(f"Latitude: {latitude}, Longitude: {longitude}")
                
                # Ask the user if they want to open the location in maps
                open_in_maps(latitude, longitude)
            else:
                print("Could not find location information.")
    else:
        print("Invalid phone number or failed to retrieve phone number information.")


####Second Method for Phone Number
def find_api_keys():
    if os.path.exists('numandcage_keys.txt'):
        with open('numandcage_keys.txt', 'r') as file:
            keys = file.readlines()
            if len(keys) == 2:
                numverify_api_key = keys[0].strip()
                opencage_api_key = keys[1].strip()
            else:
                numverify_api_key, opencage_api_key = find_and_save_keys()
    else:
        numverify_api_key, opencage_api_key = find_and_save_keys()
    
    return numverify_api_key, opencage_api_key

def find_and_save_keys():
    while True:
        numverify_api_key = input("\033[1;91m[\033[1;33;40m+\033[0m\033[1;91m] \033[1;93m Enter your Numverify API key: \033[0m").strip()
        opencage_api_key = input("\033[1;91m[\033[1;33;40m+\033[0m\033[1;91m] \033[1;93m Enter your OpenCage API key: \033[0m").strip()
        if numverify_api_key and opencage_api_key:
            with open('numandcage_keys.txt', 'w') as file:
                file.write(f"{numverify_api_key}\n{opencage_api_key}")
            return numverify_api_key, opencage_api_key
        else:
            print("\033[1;91m[\033[1;33;40m!\033[0m\033[1;91m] \033[1;93mPlease enter valid API keys.")

def find_phone_info(phone_number, numverify_api_key):
    numverify_url = f"http://apilayer.net/api/validate?access_key={numverify_api_key}&number={phone_number}"
    response = requests.get(numverify_url)
    return response.json()

def find_location_info(country_code, location, opencage_api_key):
    opencage_url = f"https://api.opencagedata.com/geocode/v1/json?q={location}&countrycode={country_code}&key={opencage_api_key}"
    response = requests.get(opencage_url)
    return response.json()

def phone_inf2():
    numverify_api_key, opencage_api_key = find_api_keys()
    
    phone_number = input("\033[1;97m[+]\033[0m\033[1;91m  Enter the phone number: \033[0m")
    print("")
    phone_info = find_phone_info(phone_number, numverify_api_key)

    if phone_info['valid']:
        print(f"\033[1;91m➤\033[1;97mPhone Number    : {phone_info['international_format']}")
        print("")
        print(f"\033[1;91m➤\033[1;97mCountry         : {phone_info['country_name']}")
        print("")
        print(f"\033[1;91m➤\033[1;97m Valid          : {phone_info['valid']}")
        print("")
        print(f"\033[1;91m➤\033[1;97mLocation        : {phone_info['location']}")
        print("")
        print(f"\033[1;91m➤\033[1;97mCarrier         : {phone_info['carrier']}")
        print("")
        print(f"\033[1;91m➤\033[1;97mLine Type       : {phone_info['line_type']}")
        print("")
        print(f"\033[1;91m➤\033[1;97mCountry Prefix  : {phone_info['country_prefix']}")
        print("")
        print(f"\033[1;91m➤\033[1;97mLocal format    : {phone_info['local_format']}")
        print("")
        print(f"\033[1;91m➤\033[1;97mCountry Code    : {phone_info['country_code']}")
        print("")
        
        location_info = find_location_info(phone_info['country_code'], phone_info['location'], opencage_api_key)
        if location_info['results']:
            location = location_info['results'][0]['geometry']
            print(f"Latitude: {location['lat']}, Longitude: {location['lng']}")
        else:
            print("Could not find location information.")
    else:
        print("Invalid phone number.")



RED = "\033[91m"
GREEN = "\033[92m"
BLUE = "\033[94m"
WHITE = "\033[0;37m"

class bcolors:
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    BOLD = '\033[1m'
    ENDC = '\033[0m'

class colors:
    CRED2 = "\33[91m"
    CBLUE2 = "\33[94m"
    ENDC = "\033[0m"

now = datetime.now()
current_time = now.strftime("%H:%M:%S")


tookie_banner = ("""\033[32m
                 ,,,,,                                    
                 ╓▄▓▓▓███████████▓▓▓▄╥                            
             ▄▓███▓▀╨╙└         └╙╙▀▓███▌▄                        
          ▄▓██▓╨─       ,▄▄▄▌▓▓▌▌▄▄╥,  ╙▀██▓▄                     
        Φ██▓╨  ╔   ╓▄▓▓▀▀╙├,,,,,,,├╙▀█▓▄  ╙▓██▌                   
      ▄██▓└     ╓▓██▄,=░░░░░░░░░░░░░░»└▓█─  └▓██▄                 
    ,▓██╨  æ   ╓▓█▀┤░░░▒▒▄╣╣▓╣╣▒▒▒▒▒░░▄▓██▄   ╙██▓                
   ╒███      ,▓█╬░░░░░░╫▓██▀▀▀██▓╬╠╠╫██└ ╙██⌐  ^███               
   ███  ╓   ╔█▓╟╣╬░░░▒╫▓█╜]▄╫█▄╫█▓╬▓█▀     ▓█─   ███              
  ▓██      ▐████╬░░░╚╙╠╫█Q'╝█▓┌╫█▓██▄░      █▌   ╚██▌             
 ]██▌  φ─  ▀▓█▓▒▒▄╠▒»,╔▒╬██▓▌▓██▓█▌╙▓▓▌▄▄░  █▌    ███             
 ╫██Γ       ██╠▓▓▓▒▒▒▒   ▒▒╬╬╩▒╫▓█▌   ╓▓██▒╫█⌐    ▓██             
 ╫██µ      ╫█▓███▒▒▒▒▒▒▒▒▒▒╣╬▒▒╠▓██▓▓██▀ ███╙ ╙▀  ╫██             
 ╟██▄  "   ▀███╬▓██▒▒▒▓▒▒▒▒╩▓▓▓▄╠▓████▌  ▀╙   ⁿ   ███             
  ███  ~   .██╬▓█▓████▒▒▒▒▒▒▒╣▓█████████,    ªÆ  ]██▓             
  ▓██▄  ,  ╫█████▓╬▓██▒▒▓▓▒▒▒▓▒╠╬▀▓▓▓████µ  ╓µ   ███              
   ███▄ └` ▄███▓███████████▓▓█▓▒▒▒▓▌▒▒███┴      ▓██▀              
    ███▄  ╟███████▓╬█▓╬╬╣████▓██▓▓████████µ   ,███▀               
     ▀███┬▐███████████▓▓███████████▓█▓▓███   ▄███Γ                
      └██████▓▓███████████████▓██▓▓███████▒▄███▀                  
        └▓███████▓▓▓██▓▓████▓▓███████████████▀                    
           ▀██████████████████████████████▀╙                      
              ╙▀██████████████████████▀▀─                         
                   ╙╙▀▀▓███████▀▀▀╙└                              
                                
             \033[0m""")


banner = ("""\033[38;5;208m
▒██   ██▒ ▒█████    ██████  ██▓ ███▄    █ ▄▄▄█████▓
▒▒ █ █ ▒░▒██▒  ██▒▒██    ▒ ▓██▒ ██ ▀█   █ ▓  ██▒ ▓▒
░░  █   ░▒██░  ██▒░ ▓██▄   ▒██▒▓██  ▀█ ██▒▒ ▓██░ ▒░
 ░ █ █ ▒ ▒██   ██░  ▒   ██▒░██░▓██▒  ▐▌██▒░ ▓██▓ ░ 
▒██▒ ▒██▒░ ████▓▒░▒██████▒▒░██░▒██░   ▓██░  ▒██▒ ░ 
▒▒ ░ ░▓ ░░ ▒░▒░▒░ ▒ ▒▓▒ ▒ ░░▓  ░ ▒░   ▒ ▒   ▒ ░░   
░░   ░▒ ░  ░ ▒ ▒░ ░ ░▒  ░ ░ ▒ ░░ ░░   ░ ▒░    ░    
 ░    ░  ░ ░ ░ ▒  ░  ░  ░   ▒ ░   ░   ░ ░   ░      
 ░    ░      ░ ░        ░   ░           ░          
   \033[1;37mAn Open Source Intelligence Framework                          
        Created by: AnonyminHack5
        Team: TermuxHackz Society\033[0m
        	Version: \033[1;92m2.2\033[0m
	   \033[1;97mPlatform: \033[0m\033[1;96m""" + platform.system())


for col in banner:
    print(colors.CRED2 + col, end="")
    sys.stdout.flush()
    time.sleep(0.0025)


main_menu = ("""
	\033[1;91m[??] Choose an option:
	\033[1;91m[\033[1;33;40m1\033[0m\033[1;91m] \033[1;97m IP Address Information
	\033[1;91m[\033[1;33;40m2\033[0m\033[1;91m] \033[1;97m Email Address Information
	\033[1;91m[\033[1;33;40m3\033[0m\033[1;91m] \033[1;97m Get Location from Image  \033[1;91m[\033[1;92mNEW!\033[0m\033[1;91m]
	\033[1;91m[\033[1;33;40m4\033[0m\033[1;91m] \033[1;97m Host Search
	\033[1;91m[\033[1;33;40m5\033[0m\033[1;91m] \033[1;97m Ports
	\033[1;91m[\033[1;33;40m6\033[0m\033[1;91m] \033[1;97m Exploit CVE
	\033[1;91m[\033[1;33;40m7\033[0m\033[1;91m] \033[1;97m Exploit Open Source Vulnerability Database 
	\033[1;91m[\033[1;33;40m8\033[0m\033[1;91m] \033[1;97m DNS Lookup
	\033[1;91m[\033[1;33;40m9\033[0m\033[1;91m] \033[1;97m DNS Reverse
        \033[1;91m[\033[1;33;40m10\033[0m\033[1;91m] \033[1;97mEmail Finder
        \033[1;91m[\033[1;33;40m11\033[0m\033[1;91m] \033[1;97mExtract Metadata from image
        \033[1;91m[\033[1;33;40m12\033[0m\033[1;91m]\033[1;97m Check Twitter Status
        \033[1;91m[\033[1;33;40m13\033[0m\033[1;91m]\033[1;97m Subdomain Enumeration
        \033[1;91m[\033[1;33;40m14\033[0m\033[1;91m]\033[1;97m Google Dork Hacking
        \033[1;91m[\033[1;33;40m15\033[0m\033[1;91m]\033[1;97m SMTP Analysis
        \033[1;91m[\033[1;33;40m16\033[0m\033[1;91m]\033[1;97m Check Global InfoStealer Attack \033[1;91m[\033[1;92mNEW!\033[0m\033[1;91m]
        \033[1;91m[\033[1;33;40m17\033[0m\033[1;91m]\033[1;97m Dark Web Search
        \033[1;91m[\033[1;33;40m18\033[0m\033[1;91m]\033[38;5;208m Next Tools >
        \033[1;91m[\033[1;33;40m19\033[0m\033[1;91m]\033[1;97m Report bugs
	\033[1;91m[\033[1;33;40m99\033[0m\033[1;91m]\033[1;97m Update X-osint
	\033[1;91m[\033[1;33;40m100\033[0m\033[1;91m]\033[1;97m About
	\033[1;91m[\033[1;33;40m00\033[0m\033[1;91m]\033[1;97m Quit
	
	""")


about = """\033[1;90m
This is an osint tool which gathers useful and yet credible valid information about a phone number, user email address and ip address, \nVIN, Protonmail account and so much more, X-osint is an Open source intelligence framework, \nfeel free to clone this repo, if you have features you would like to add or any fixes please open an issue or create a merge
\033[0m"""
def traceip():
	targetip = input("\033[1;91mEnter IP Address: \033[0m")
	r = requests.get("http://ip-api.com/json/" + targetip)
	print("\n\033[1;91m[*]\033[1;97m IP detail is given down below\n")
	#print()
	sleep(0.1)
	print("\033[1;92m \033[1;91m➤\033[1;97m Status Code    : " + str(r.status_code))
	sleep(0.1)
	if str(r.json() ['status']) == 'success':
		print(" \033[1;91m➤\033[1;97m Status         :\033[1;92m " + str(r.json() ['status']))
		sleep(0.1)
	elif str(r.json() ['status']) == 'fail':
		print(" \033[1;91m➤\033[1;97m Status         :\033[1;97m " + str(r.json() ['status']) + '\033[1;92m')
		sleep(0.1)
		print(" \033[1;91m➤\033[1;97m Message        : " + str(r.json() ['message']))
		sleep(0.1)
		if str(r.json() ['message']) == 'invalid query':
			print('\n\033[1;91m[!] \033[1;97m' + targetip + ' is an invalid IP Address, So you can try another IP Address.\n')
			exit()
		elif str(r.json() ['message']) == 'private range':
			print('\n\033[1;91m[!] \033[1;97m' + targetip + ' is a private IP Address, So This IP can not be traced.\n')
			exit()
		elif str(r.json() ['message']) == 'reserved range':
			print('\n\033[1;91m[!] \033[1;97m' + targetip + ' is a reserved IP Address, So This IP can not be traced.\n')
			exit()
		else:
			print('\nCheck your internet connection.\n')
			exit()
	print("\033[1;92m \033[1;91m➤\033[1;97m Target IP      : " + str(r.json() ['query'] ))
	sleep(0.1)
	print("\033[1;92m \033[1;91m➤\033[1;97m Country:	: " + str(r.json() ['country'] ))
	sleep(0.1)
	print(" \033[1;92m\033[1;97m➤\033[1;97m Country Code    : " + str(r.json() ['countryCode']))
	sleep(0.1)
	print(" \033[1;92m\033[1;97m➤\033[1;97m City   	: " + str(r.json() ['city']))
	sleep(0.1)
	print(" \033[1;92m\033[1;97m➤\033[1;97m Timezone    	: " + str(r.json() ['timezone']))
	sleep(0.1)
	print(" \033[1;91m➤\033[1;97m Region Name    : " + str(r.json() ['regionName'] ))
	sleep(0.1)
	print(" \033[1;91m➤\033[1;97m Region         : " + str(r.json() ['region'] ))
	sleep(0.1)
	print(" \033[1;91m➤\033[1;97m ZIP Code       : " + str(r.json() ['zip'] ))
	sleep(0.1)
	print(" \033[1;91m➤\033[1;97m Latitude       : " + str(r.json() ['lat'] ))
	sleep(0.1)
	print(" \033[1;91m➤\033[1;97m Longitude      : " + str(r.json() ['lon'] ))
	sleep(0.1)
	print(" \033[1;91m➤\033[1;97m ISP            : " + str(r.json() ['isp'] ))
	sleep(0.1)
	print(" \033[1;91m➤\033[1;97m Organization   : " + str(r.json() ['org'] ))
	sleep(0.1)
	print(" \033[1;91m➤\033[1;97m AS             : " + str(r.json() ['as'] ))
	sleep(0.1)
	print(" \033[1;91m➤\033[1;97m Location       : " + str(r.json() ['lat']) + ',' + str(r.json() ['lon']))
	sleep(0.1)
	print(" \033[1;91m➤\033[1;97m Google Map     : \033[1;94mhttps://maps.google.com/?q=" + str(r.json() ['lat']) + ',' + str(r.json() ['lon']))
	sleep(0.1)
	print()
	mapaddress = input("\033[1;91m[*]\033[1;97m Press ENTER To Open Location on Google maps or press any other key to quit: ")
	if mapaddress == "":
		print()
		print("[*] Opening Location on google map")
		print()
		os.system("xdg-open https://maps.google.com/?q=" + str(r.json() ['lat']) + ',' + str(r.json() ['lon']) + " > /dev/null 2>&1")
		print()
	else:
		print()
		print("[*] Aborting.....")
		print()

##Payment Support 
stripe.api_key = "sk_test_51PPJGRHFUeNFgW9qtt7XLXIZZxuFRfkdoXXOqDY9gHGWlzo4ODBuqnnOTHLKDDop5OJMhC5YdLaqO3McPnrPbfd800mcey87nX"

def create_checkout_session():
    try:
        session = stripe.checkout.Session.create(
            payment_method_types=['card'],
            line_items=[{
                'price_data': {
                    'currency': 'usd',  # Fixed currency
                    'product_data': {
                        'name': 'Support Script',
                    },
                    'unit_amount': 500,  # Amount in cents ($5.00)
                },
                'quantity': 1,
            }],
            mode='payment',
            success_url='http://127.0.0.1:5000/success',
            cancel_url='http://127.0.0.1:5000/cancel',
        )
        return session.url
    except stripe.error.StripeError as e:
        print(e)
        return None

def open_browser():
    session_url = create_checkout_session()
    if session_url:
        webbrowser.open(session_url)
    root.quit()

def close_popup():
    popup_window.destroy()
    root.quit()

def show_support_popup():
    global root, popup_window
    root.withdraw()  # Hide the root window
    popup_window = tk.Toplevel()
    popup_window.title("Support Script")

    label = tk.Label(popup_window, text="Would you like to pay to support this script?, \nThis is to ensure X-osint works well, and if it doesnt its because you didnt support the tool \n\n Payments are secured and encrypted through Stripe")
    label.pack(pady=10)

    yes_button = tk.Button(popup_window, text="Yes", command=open_browser)
    yes_button.pack(side=tk.LEFT, padx=10)

    no_button = tk.Button(popup_window, text="No", command=close_popup)
    no_button.pack(side=tk.RIGHT, padx=10)

    root.mainloop()

###email address information gathering
def email_info():
	mailid = input("\033[1;91mEnter email address: \033[1;94m")
	if not re.match(r"[^@]+@[^@]+\.[^@]+", mailid):
		print("Please input a valid Email Address!")
		return
	eml = requests.get("https://ipqualityscore.com/api/json/email/lPnx5AhAUv4jgIFDXquYpe8CVBjmaTii/" + mailid)
	if str(eml.json()['success']) == "False":
		print(eml.json()['message'])
		return
	print()
	sleep(1)
	print()
	print("\033[1;91m[~]\033[1;97m E-mail Details are given down below")
	print()
	print("\033[1;91m➤\033[1;97m Target E-mail       : " + str(mailid) )
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Status Code         : " + str(eml.status_code) )
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Valid               : " + str(eml.json() ['valid']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Catch All           : " + str(eml.json() ['catch_all']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Common              : " + str(eml.json() ['common']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Deliverability      : " + str(eml.json() ['deliverability']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Disposable          : " + str(eml.json() ['disposable']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m DNS Valid           : " + str(eml.json() ['dns_valid']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Fraud Score         : " + str(eml.json() ['fraud_score']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Frequent Complainer : " + str(eml.json() ['frequent_complainer']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Generic             : " + str(eml.json() ['generic']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Honeypot            : " + str(eml.json() ['honeypot']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Leaked              : " + str(eml.json() ['leaked']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Message             : " + str(eml.json() ['message']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Over All Score      : " + str(eml.json() ['overall_score']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Recent Abuse        : " + str(eml.json() ['recent_abuse']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Request ID          : " + str(eml.json() ['request_id']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Sanitized E-mail    : " + str(eml.json() ['sanitized_email']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m SMTP Score          : " + str(eml.json() ['smtp_score']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Spam Trap Score     : " + str(eml.json() ['spam_trap_score']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Success             : " + str(eml.json() ['success']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Suggested Domain    : " + str(eml.json() ['suggested_domain']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Suspect             : " + str(eml.json() ['suspect']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Timed Out           : " + str(eml.json() ['timed_out']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m First Name          : " + str(eml.json() ['first_name']))
	sleep(0.1)
	print()
	print("\033[1;91m[~]\033[1;94m Domain Age")
	print()
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Human      : " + str(eml.json() ['domain_age'] ['human']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m ISO        : " + str(eml.json() ['domain_age'] ['iso']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Time Stamp : " + str(eml.json() ['domain_age'] ['timestamp']))
	sleep(0.1)
	print()
	print("\033[1;91m[~]\033[1;94m First Seen")
	print()
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Human      : " + str(eml.json() ['first_seen'] ['human']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m ISO        : " + str(eml.json() ['first_seen'] ['iso']))
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Time Stamp : " + str(eml.json() ['first_seen'] ['timestamp']))
	sleep(0.1)
	print()
 
 ### Phone number info
def get_decimal_from_dms(dms, ref):
    degrees = dms[0][0] / dms[0][1]
    minutes = dms[1][0] / dms[1][1] / 60.0
    seconds = dms[2][0] / dms[2][1] / 3600.0

    decimal = degrees + minutes + seconds
    if ref == "S" or ref == "W":
        decimal = -decimal
    return decimal

def extract_gps_info(image_path):
    if not os.path.exists(image_path):
        print(f"The file {image_path} does not exist.")
        return None

    img = Image.open(image_path)
    exif_data = piexif.load(img.info['exif'])

    gps_data = exif_data.get("GPS", None)
    if not gps_data:
        print("No GPS information found in the image...sorry, try another hehe")
        return None

    gps_latitude = gps_data.get(piexif.GPSIFD.GPSLatitude)
    gps_latitude_ref = gps_data.get(piexif.GPSIFD.GPSLatitudeRef).decode()
    gps_longitude = gps_data.get(piexif.GPSIFD.GPSLongitude)
    gps_longitude_ref = gps_data.get(piexif.GPSIFD.GPSLongitudeRef).decode()

    if not all([gps_latitude, gps_latitude_ref, gps_longitude, gps_longitude_ref]):
        print("Incomplete GPS information found in the image.")
        return None

    lat = get_decimal_from_dms(gps_latitude, gps_latitude_ref)
    lon = get_decimal_from_dms(gps_longitude, gps_longitude_ref)

    return lat, lon

def open_map(lat, lon):
    map_url = f"https://www.google.com/maps?q={lat},{lon}"
    webbrowser.open(map_url)
    print(f"Opened map at {lat}, {lon}")



#### Update script
def update():
	os.system("clear")
	print(banner)
	print()
	print("\033[1;91m➤\033[1;97m Searching for updates...-> \033[0m\033[1;94mFound")
	sleep(0.1)
	print("\033[1;91m➤\033[1;97m Updating.. \033[0m")
	sleep(0.1)
	print()
	print()
	print("\033[1;91m\tSelect your terminal for update \033[0m\n")
	print("\033[1;91m\t[!] PLEASE MAKE SURE YOU CHOOSE CORRECTLY [!] \033[0m\n\n")
	print("\033[1;34m\t\t[\033[0m\033[1;77m1\033[0m\033[1;34m]\033[0m\033[1;93mTermux\033[0m")
	print("\033[1;34m\t\t[\033[0m\033[1;77m2\033[0m\033[1;34m]\033[0m\033[1;93mLinux\033[0m\n")
	update_terminal = input("\033[1;94mChoose: \033[0m")
	
	if update_terminal == "1":
		print("\033[1;97m[+] Updating for termux......\033[0m")
		print()
		sleep(0.1)
		os.system("cd $HOME")
		os.system("cd $PREFIX/bin && rm xosint")
		print("\033[1;97m[+] Validating installation....\033[0m\n")
		sleep(0.1)
		path_to_file = '/$PREFIX/bin/xosint'
		path = Path(path_to_file)
		if path.is_file():
			print(f'The file {path_to_file} exists, Validation failed, Kindly update manually')
			time.sleep(1)
			exit()
		else:
			print(f'The file {path_to_file} doesnt exists, Validation Successful')
			time.sleep(0.5)
			print("\033[1;91m[!]\033[0m\033[1;97mAutomatic update Completed\0330m\n")
			time.sleep(0.9)
			os.system("cd $HOME")
			os.system("git clone https://github.com/TermuxHackz/X-osint")
			print("\033[1;97m[+] Granting permissions.....\033[0m\n")
			os.system("cd $HOME && cd X-osint")
			os.system("chmod +x *")
			sleep(0.5)
			print("\033[1;97m[+] Preparing Setup file.....\033[0m\n")
			sleep(0.5)
			print("\033[1;97m[+] Setup file ready!!.....Starting in 2s...\033[0m\n")
			print("\033[1;97m[+] Update completed.....\033[0m\n")
			sleep(2)
			os.system("cd $HOME ")
			os.system("cd X-osint && bash setup.sh")

			

	elif update_terminal == "2":
		print("\033[1;97m[+] Updating for linux......\033[0m")
		print()
		sleep(0.1)
		os.system("cd $HOME")
		os.system("cd /usr/local/bin && sudo rm xosint")
		print("\033[1;97m[+] Validating installation....\033[0m\n")
		sleep(0.5)
		path_to_file = '/usr/local/bin/xosint'
		path = Path(path_to_file)
		if path.is_file():
			print(f'The file {path_to_file} exists, Validation failed, Kindly update manually')
			time.sleep(1)
			exit()
		else:
			os.system("cd $HOME")
			os.system("git clone https://github.com/TermuxHackz/X-osint")
			print("")
			print("\033[1;97m[+] Granting permissions.....\033[0m\n")
			os.system("cd X-osint")
			os.system("sudo chmod +x *")
			sleep(0.5)
			print("\033[1;97m[+] Preparing Setup file.....\033[0m\n")
			sleep(0.5)
			print("\033[1;97m[+] Setup file ready!!.....Starting in 2s...\033[0m\n")
			print("\033[1;97m[+] Update completed.....\033[0m\n")
			sleep(2)
			os.system("cd $HOME")
			os.system("cd X-osint && bash setup.sh")
	else:
		print("Invalid input....KINDLY UPDATE...quiting..")
		sleep(0.5)
		exit
		
#### Start main script
### 4, 5, 6, 7
os.system("clear")
global root
root = tk.Tk()
root.withdraw() 

##Fetchupdate
##update_script() ####----->ENABLE THIS 

show_support_popup()
print(banner)
print(main_menu)
option = input("\033[38;5;208mxosint>> \033[1;97m") 
if option == "1":
	traceip()
elif option == "2":
	email_info()
elif option == "3":
    def main():
        image_path = input("Enter the path to the image: ").strip()
        location = extract_gps_info(image_path)
        if location:
            print("\033[1;91m[+]\033[0m\033[1;97mMaps Location wil be opened in 3secs.. \033[0m")
            time.sleep(3)
            open_map(*location)
    main()
	
elif option == "4":
	def shodan_host():
		if os.path.exists("./api.txt") and os.path.getsize("./api.txt") > 0:
			with open('api.txt', 'r') as file:
				shodan_api=file.readline().rstrip('\n')
		else:
			file = open('api.txt', 'w')
			shodan_api = input("[+] Please enter a valid Shodan API key (Shodan.io): ")
			file.write(shodan_api)
			print("[+] File written: ./api.txt")
			file.close()
		host_ip = input("\033[1;91m[+]\033[0m\033[1;97mShodan Host Search (IP): \033[0m")
		url = "https://api.shodan.io/shodan/host/"+ host_ip +"?key=" + shodan_api
		request = requests.get(url)
		txt = request.text
		parsed = json.loads(txt)
		print(json.dumps(parsed, indent=2, sort_keys=True))
	shodan_host()
elif option == "5":
	def shodan_ports():
		if os.path.exists("./api.txt") and os.path.getsize("./api.txt") > 0:
			with open('api.txt', 'r') as file:
				shodan_api=file.readline().rstrip('\n')
		else:
			file = open('api.txt', 'w')
			shodan_api = input("[+] Please enter a valid Shodan API key (Shodan.io): ")
			file.write(shodan_api)
			print("[+] File written: ./api.txt")
			file.close()
		url = "https://api.shodan.io/shodan/ports?key=" + shodan_api
		request = requests.get(url)
		txt = request.text
		parsed = json.loads(txt)
		print(json.dumps(parsed, indent=2, sort_keys=True))
	shodan_ports()
elif option == "6":
	def shodan_exploit_cve():
		if os.path.exists("./api.txt") and os.path.getsize("./api.txt") > 0:
			with open('api.txt', 'r') as file:
				shodan_api=file.readline().rstrip('\n')
		else:
			file = open('api.txt', 'w')
			shodan_api = input("[+] Please enter a valid Shodan API key (Shodan.io): ")
			file.write(shodan_api)
			print("[+] File written: ./api.txt")
			file.close()
		exploit_cve = input("\033[1;91m[+]\033[0m\033[1;97mExploit CVE: \033[0m")
		url = "https://exploits.shodan.io/api/search?query="+ "cve:" + exploit_cve +"&key=" + shodan_api
		request = requests.get(url)
		txt = request.text
		parsed = json.loads(txt)
		print(json.dumps(parsed, indent=2, sort_keys=True))
	shodan_exploit_cve()
elif option == "7":
	def shodan_exploit_osvdb():
		if os.path.exists("./api.txt") and os.path.getsize("./api.txt") > 0:
			with open('api.txt', 'r') as file:
				shodan_api=file.readline().rstrip('\n')
		else:
			file = open('api.txt', 'w')
			shodan_api = input("[+] Please enter a valid Shodan API key (Shodan.io): ")
			file.write(shodan_api)
			print("[+] File written: ./api.txt")
			file.close()
		exploit_osvdb = input("\033[1;91m[+]\033[0m\033[1;97mExploit Open Source Vulnerability Database: \033[0m")
		url = "https://exploits.shodan.io/api/search?query="+ "osvdb:" + exploit_osvdb +"&key=" + shodan_api
		request = requests.get(url)
		txt = request.text
		parsed = json.loads(txt)
		print(json.dumps(parsed, indent=2, sort_keys=True))
	shodan_exploit_osvdb()
	
elif option == "8":
	def shodan_dns_lookup():
		if os.path.exists("./api.txt") and os.path.getsize("./api.txt") > 0:
			with open('api.txt', 'r') as file:
				shodan_api=file.readline().rstrip('\n')
		else:
			file = open('api.txt', 'w')
			shodan_api = input("[+] Please enter a valid Shodan API key (Shodan.io): ")
			file.write(shodan_api)
			print("[+] File written: ./api.txt")
			file.close()
		hostnames = input("\033[1;91m[+]\033[0m\033[1;97mDNS Lookup: \033[0m")
		url = "https://api.shodan.io/dns/resolve?hostnames="+ hostnames +"&key=" + shodan_api
		request = requests.get(url)
		txt = request.text
		parsed = json.loads(txt)
		print(json.dumps(parsed, indent=2, sort_keys=True))
	shodan_dns_lookup()
	
elif option == "9":
	def shodan_dns_reverse():
		if os.path.exists("./api.txt") and os.path.getsize("./api.txt") > 0:
			with open('api.txt', 'r') as file:
				shodan_api=file.readline().rstrip('\n')
		else:
			file = open('api.txt', 'w')
			shodan_api = input("[+] Please enter a valid Shodan API key (Shodan.io): ")
			file.write(shodan_api)
			print("[+] File written: ./api.txt")
			file.close()
		ips = input("\033[1;91m[+]\033[0m\033[1;97mDNS Reverse: \033[0m")
		url = "https://api.shodan.io/dns/reverse?ips="+ ips +"&key=" + shodan_api
		request = requests.get(url)
		txt = request.text
		parsed = json.loads(txt)
		print(json.dumps(parsed, indent=2, sort_keys=True))
	shodan_dns_reverse()

elif option == "10":
	def hunter_email_finder():
		email_domain = input("\033[1;91m[+]\033[0m\033[1;97mDomain: \033[0m")
		first_name = input("\033[1;91m[+]\033[0m\033[1;97mFirst Name: \033[0m")
		last_name = input("\033[1;91m[+]\033[0m\033[1;97mLast Name: \033[0m")
		url = "https://api.hunter.io/v2/email-finder?domain="+ email_domain + "&first_name=" + first_name +"&last_name=" + last_name +"&api_key=" + hunter_api
		request = requests.get(url)
		txt = request.text
		parsed = json.loads(txt)
		print(json.dumps(parsed, indent=2, sort_keys=True))

	if os.path.exists("./hunter_io_api.txt") and os.path.getsize("./hunter_io_api.txt") > 0:
		with open('hunter_io_api.txt', 'r') as file:
			hunter_api=file.readline().rstrip('\n')
	else:
		file = open('hunter_io_api', 'w')
		hunter_api = input("[+] Please enter a valid Hunter API key to continue (Get from Hunter.io): ")
		file.write(hunter_api)
		print("[+] File written: ./hunter_io_api.txt")
		file.close()
		hunter_email_finder()

	def hunter_email_finder():
		email_domain = input("\033[1;91m[+]\033[0m\033[1;97mDomain: \033[0m")
		first_name = input("\033[1;91m[+]\033[0m\033[1;97mFirst Name: \033[0m")
		last_name = input("\033[1;91m[+]\033[0m\033[1;97mLast Name: \033[0m")
		url = "https://api.hunter.io/v2/email-finder?domain="+ email_domain + "&first_name=" + first_name +"&last_name=" + last_name +"&api_key=" + hunter_api
		request = requests.get(url)
		txt = request.text
		parsed = json.loads(txt)
		print(json.dumps(parsed, indent=2, sort_keys=True))

elif option == "11":
	print("\033[1;91m[!]NOTICE:\033[0m\033[1;93m To get a better metadata of the image please do not use images from whatsapp or social media platforms as they strip away metadata from images, also do not use screenshot images, USE IMAGES TAKEN FROM A DEVICE CAMERA THANK YOU [!]\033[0m")
	print()
	imagename = input("\033[1;91m[+]\033[0m\033[1;97m Enter Correct path of the image (JPEG ONLY): \033[0m")
	print("")
	print()
	# open the image
	exif_dict = piexif.load(imagename)
	print(f'Metadata for {imagename}:')
	for ifd in exif_dict:
		print(f'{ifd}:')
		for tag in exif_dict[ifd]:
			tag_name = piexif.TAGS[ifd][tag]["name"]
			tag_value = exif_dict[ifd][tag]
			
			if isinstance(tag_value, bytes):
				tag_value = tag_value[:10]
			print(f'\t{tag_name:25}: {tag_value}')
	print()

		
elif option == "12":
	email_add = input("\033[1;91m[+]\033[0m\033[1;97mEnter email: \033[0m")
	url = "https://api.twitter.com/i/users/email_available.json?email=" + email_add 
	request = requests.get(url)
	txt = request.text
	parsed = json.loads(txt)
	print(json.dumps(parsed, indent=2, sort_keys=True))
			
elif option == "13":
	import resolver
	import threading

	domain = input("\033[1;91m[+]\033[0m\033[1;97mEnter domain name (without www): \033[0m")
	file_path = input("\033[1;91m[+]\033[0m\033[1;97mPath of subdomains lists (Get from my github): \033[0m")
	
	def check_host(self, host):
		is_valid = False
		Resolver = dns.resolver.Resolver()
		Resolver.nameservers = ['1.1.1.1', '1.0.0.1']
		self.lock.acquire()
		try:
			ip = Resolver.query(host, 'A')[0].to_text()
			if ip:
				if self.verbose:
					self_print_("%s%: %s%" % (R, self.engine_name, W, host))
					is_valid = True
					self.live_subdomains.append(host)
		except:
			pass
			self.lock.release()
			return is_valid
	sub_list = open(file_path).read()
	subs = sub_list.splitlines()
	
	for sub in subs:
		domain = f"http://{sub}.{domain}"
		
		try:
			requests.get(domain)
		except requests.ConnectionError:
			pass
		else:
			print("\033[1;94m[+]\033[0m Valid Subdomain: ",domain)
	def domain(self):
		sleep(0.2)
	def __domain__(self):
		t.threading.Thread(target=self.domain)
		t.start()
#### Google Dorking Hacking 

elif option == "14":
		try:
			## print_formatted_text(HTML('<b><u>;GOOGLE DORK HACKING </u></b>')) 
			dork = input('\033[1;91m\n[+]\033[0m\033[1;97mEnter The Dork Search Query (eg: intext:"Index of /" +passwd): \033[0m')
			amount = input("\033[1;91m[+]\033[0m\033[1;97mEnter The Number Of sites To dork (eg: 4): \033[0m")
			print ("\n ")
			
			requ = 0
			counter = 0
			
			for results in search(dork, tld="com", lang="en", num=int(amount), start=0, stop=None, pause=2):
				counter = counter + 1
				print ("[+] ", counter, results)
				time.sleep(0.1)
				requ += 1
				if requ >= int(amount):
					break
				data = (counter, results)
				time.sleep(0.1)
				print("\n")
			file = input('\033[1;91m[!]\033[0m\033[1;94mEnter name to save output as (eg: output.txt): \033[0m')
			original_stdout = sys.stdout
			try:
				with open(file, 'w') as f:
					sys.stdout = f
					print(data)
					print("\n")
					sys.stdout = original_stdout
					print("\033[1;97m[+]\033[0mFile has been saved as \033[0m" + file)
			except:
				print("\033[1;91m[!]Please enter a name to save the file as [!]\033[0m")
				sys.exit(1)

		except KeyboardInterrupt:
			print ("\n")
			print ("\033[1;91m[!] User Interruption Detected..!\033[0")
			time.sleep(0.5)
			print ("[•] Done... Exiting...")
			sys.exit(1)
			
elif option == "19":
	print("\033[1;91m[+]\033[1;97m Kindly take a screenshot or screenrecord of the error faced and mail them \nto me and i would give you feedback based on those bugs you have \nreported to me and fix them, Thank you \033[0m")
	print("")
	try:
		report = input('\033[1;95mReport bug (y/n): \033[0m')
		if report == "y":
			try:
				import webbrowser
				webbrowser.open('mailto:?to=AnonyminHack5@protonmail.com&subject=X-osint-bugs', new=1)
			except ImportError:
				print("\033[1;91m[!] Webbrowser module not found!!, Install using \033[0m\033[1;97mpip install webbrowser\033[0m")
				print("[+] Try reporting bugs again ")
				time.sleep(0.9)
				sys.exit(1)
		elif report == "n":
			print("[+] Seems there wasnt any bugs for you to report, so why bother choosing to report bugs, lol ")
			time.sleep(0.5)
			sys.exit(1)
		else:
			print("\033[1;91m[!] Invalid Command!!!\033[0m")
			time.sleep(0.1)
			sys.exit(1)
	except KeyboardInterrupt:
		print ("\n")
		print ("\033[1;91m[!] User Interruption Detected..!\033[0")
		time.sleep(0.5)
		sys.exit(1)
elif option == "15":
	def spoof(target,ports):
		TestedPorts = []
		if ("ports"=="*"):
			TestedPorts = ['25','465','587','2525']
			ports = "25, 465, 587 and 2525"
		else:
			TestedPorts = list(ports.split(","))
			testuser = "testuser@mail.ca"
			message = MIMEMultipart()
			message["From"] = testuser
			message["To"] = testuser
			message["Subject"] = "test"
			text = message.as_string()
			print("\033[1;91m{}[!]\033[0m\033[1;97mLooking For Email Spooffing Vulnerability on port {}..... \033[0m\033[1;91m[!]\033[0m\n\033[94m".format(WHITE,ports))
			for port in TestedPorts: 
				print("{} Testing Email Spoofing on port {}.....\n\033[94m".format(WHITE,port))
			try:
				SMTP(target,port).sendmail(testuser,testuser,text)
				print("{} The SMTP Server Targeted : {} is potentialy vulnerable to mail spoofing. Authentification don't seem to be required on port {} \033[0;37m \n".format(GREEN,target,port))
			except (SMTPRecipientsRefused, SMTPSenderRefused, SMTPResponseException):
				print("{} Recipient error encountered. The SMTP Server Targeted: {} don't seem to be vunlerable to mail spoofing on port {} \033[0;37m \n ".format(BLUE,target,port))
			except ConnectionRefusedError:
				print("{} Connection refused by host {}. It don't seem to be vunlerable to mail spoofing on port {} \033[0;37m \n".format(BLUE,target,port))
			except Exception:
				print("{} Exception Occured on host {}. It don't seem to be vunlerable to mail spoofing on port {} \033[0;37m \n".format(BLUE,target,port))
			except KeyboardInterrupt:
				print("Stopping...")
				exit()
	def userenum (target,ports):
		TestedPorts = []
		if (ports =="*"):
			TestedPorts = ['25','465','587','2525']
			ports = "25, 465, 587 and 2525"
		else:
			TestedPorts = list(ports.split(","))
			print("\033[1;91m{}[!]\033[0m\033[1;97m Looking For user enumeration vulnerability on port {}..... \033[0m\n\033[94m".format(WHITE,ports))
		for port in TestedPorts:
			print("\033[1;91m{}[!]\033[0m\033[1;997m Testing user enumeration on port {}.....\033[0m\n\033[94m".format(WHITE,port))
		try:
			verify = SMTP(target, port).verify("")
			if verify[0] in [250, 252]:
				print("{} The SMTP Server Targeted: {} is potentialy vulnerable to user enumeration on port {}. VRFY query responded status : {}  \033[0;37m \n".format(GREEN,target,port,verify[0]))
			else:
				print("{} The SMTP Server Targeted: {} don't seem to be vulberable to user enumeration on port {}. VRFY query responded statys : {}  \033[0;37m \n".format(BLUE,target,port,verify[0]))
		except Exception:
			print("{} Exception Occured on host {}. It don't seem to be vunlerable to user enumeration on port {}. \033[0;37m \n".format(BLUE,target,port))
		except KeyboardInterrupt:
			print("Stopping...")
			exit()

	target = input("\033[1;91m[+]\033[0m\033[1;97mEnter SMTP Server: \033[0m")
	port = input('\033[1;91m[+]\033[0m\033[1;97mEnter port or type "*" to use all ports: \033[0m')
	spoof(target,port)
	userenum(target,port)
 
#### InfoStealer Attack
elif option == "16":
    W = '\033[0m'
    C = '\033[36m'
    R = '\033[31m'
    G = '\033[32m'
 
    os.system("clear")
    print(banner)
    ten_main_menu = ("""
                     \033[1;91m[??] Choose an option:
                     \033[1;91m[\033[1;33;40m1\033[0m\033[1;91m] \033[1;97m Check Email Data Breach
                     \033[1;91m[\033[1;33;40m2\033[0m\033[1;91m] \033[1;97m Check Domain Data Breach
                     \033[1;91m[\033[1;33;40m3\033[0m\033[1;91m] \033[1;97m Check Username Data Breach
                     \033[1;91m[\033[1;33;40mG\033[0m\033[1;91m] \033[1;97m Go back
                     """) ##I would still add more here
    print(ten_main_menu)
    ten_input = input('\033[38;5;208mxosint>> \033[0m')
    
    if ten_input == "1":
        email_answer = input("\033[1;91m[+]\033[1;97m Enter the email to check for Data Breach: \033[0m")
        print("")
        def search_by_email(email_answer):
            api_url = "https://cavalier.hudsonrock.com/api/json/v2/osint-tools/search-by-email"
            url = f"{api_url}?email={email_answer}"
            
            
            try:
                response = requests.get(url)
                response.raise_for_status()
                data = response.json()
                return data
            
            except requests.exceptions.RequestException as e:
                print(f"[!] An Error Occured: {e}")
                return None
            
        result = search_by_email(email_answer) # type: ignore
        if result:
            print("\033[1;91m[+]\033[0m\033[1;97m Breached Data: \033[0m")
            import json
            print(json.dumps(result, indent=4))
        else:
            print("\033[1;91m[+]\033[0m\033[1;97m No Data found or an error occurred. \033[0m")
    
    elif ten_input == "2":
        domain_answer = input("\033[1;91m[+]\033[1;97m Enter the Doamin to check (ending in .com): \033[0m")
        print("")
        def search_by_domain(domain_answer):
            api_url = "https://cavalier.hudsonrock.com/api/json/v2/osint-tools/search-by-domain"
            url = f"{api_url}?domain={domain_answer}"
            
            try:
                response = requests.get(url)
                response.raise_for_status()
                data = response.json()
                return data
            except requests.exceptions.RequestException as e:
                print(f"[!] An Error Occured: {e}")
                return None
        
        result2 = search_by_domain(domain_answer)
        if result2:
            print("\033[1;91m[+]\033[0m\033[1;97m Breached Data: \033[0m")
            import json
            print(json.dumps(result2, indent=4))
        else:
            print("\033[1;91m[+]\033[0m\033[1;97m No Data found or an Error Occurred. \033[0m")
            
    
    elif ten_input == "3":
        username_answer = input("\033[1;91m[+]\033[1;97m Enter the Username to check: \033[0m")
        print("")
        def search_by_domain(username_answer):
            api_url = "https://cavalier.hudsonrock.com/api/json/v2/osint-tools/search-by-username"
            url = f"{api_url}?username={username_answer}"
            
            try:
                response = requests.get(url)
                response.raise_for_status()
                data = response.json()
                return data
            except requests.exceptions.RequestException as e:
                print(f"[!] An Error Occured: {e}")
                return None
        
        result3 = search_by_domain(username_answer)
        if result3:
            print("\033[1;91m[+]\033[0m\033[1;97m Breached Data: \033[0m")
            import json
            print(json.dumps(result3, indent=4))
        else:
            print("\033[1;91m[+]\033[0m\033[1;97m No Data found or an Error Occurred. \033[0m")
        

    elif ten_input == "G" or "g":
        os.system("cd $HOME")
        os.system("sudo xosint || xosint || python xosint")
    
    else:
        print("\033[1;91m[!]\033[0m\033[1;97mInvalid Command..exiting\033[0m")
        time.sleep(0.0001)
        exit()
        


#### DEEP WEB SCRAPING OSINT

elif option == "17":
	W = '\033[0m'
	C = '\033[36m'
	R = '\033[31m'
	G = '\033[32m'
	
	try:
		import subprocess as subp
	except ImportError:
		print("Required Module not installed...exiting")
		exit()

	def service():
		print('\n' + C + "[~]Checking for tor service...." + W + '\n')
		if platform.system() == "Linux":
			cmd = 'systemctl is-active tor.service && tor'
			co = subp.Popen(cmd, shell=True,stdout=subp.PIPE).communicate()[0]
			if 'inactive' in str(co):
				print(R + '[!] Tor Service is not Running ' + W + '\n')
				print(R + '[!] Tor Service is required to Run this feature... ')
				print(R + '[!] Type' + W + " tor " + R + 'if your using termux or type' + W + " service tor start " + R + 'if your using linux\n')
				print(C + '[*] After doing that run ' + W + " xosint " + C + 'again ') 
				exit()
			else:
				print(C + '[+] Tor Service is running....' + W + '\n')
		else:
			command = "tor"
			os.system(command)
			print(C + '[+] Tor Service is running...' + W + '\n')

	def scrap():
		r = "http://icanhazip.com"
		page = requests.get(r)
		print(R + '[+]' + G + ' Connected to Tor....')
		print(R + '[->]' + G + 'Your tor ip --> ' + page.text)
	
	
	def main():
		from bs4 import BeautifulSoup
		
		session = requests.session()
		#session.proxies["http"] = "127.0.0.1:9050" 
		#session.proxies["https"] = "127.0.0.1:9050"
		
		
		query = input('\033[1;91m[+]\033[0m\033[1;94mEnter keyword to search: \033[0m')
		URL = f"https://ahmia.fi/search/?q={query}"
		page = requests.get(URL)
		request = requests.get(URL)
		
		if request.status_code == 200:
			print('\n' + G + '[!] Request went through \n')
			time.sleep(0.5)
			print(G + '[+] Getting .onion links for you: [+] \033[0m\n')
			time.sleep(0.5)
			soup = BeautifulSoup(page.content, "html.parser")
			for a_href in soup.find_all("a", href=True):
				print(a_href["href"])
			time.sleep(0.5)
			choice = input('\033[1;91m[+]\033[0m\033[1;94mOpen results in browser? (y/n): \033[0m')
			if choice == "y":
				import webbrowser
				webbrowser.open(f"https://ahmia.fi/search/?q={query}")
				time.sleep(0.5)
				print("If it doesnt open, its most likely your using Termux")
			elif choice == "n":
				sys.exit(1)
			else:
				print("Wrong input")
				exit()
		else:
			print(R + '[!] Request didnt go through please check your network or try again later \n')
			exit(1)
	service()
	scrap()
	main()


elif option == "18":
    os.system("clear")
    print(banner)
    second_main_menu = ("""
                     \033[1;91m[??] Choose an option:
                     \033[1;91m[\033[1;33;40m18\033[0m\033[1;91m] \033[1;97m Protonmail OSINT
                     \033[1;91m[\033[1;33;40m19\033[0m\033[1;91m] \033[1;97m Vehicle Identification Number OSINT
                     \033[1;91m[\033[1;33;40m20\033[0m\033[1;91m] \033[1;97m Basic Github OSINT
                     \033[1;91m[\033[1;33;40m21\033[0m\033[1;91m] \033[1;97m Vehicle License plate OSINT
                     \033[1;91m[\033[1;33;40m22\033[0m\033[1;91m] \033[1;97m ImageHunt \033[1;91m[\033[1;92mBETA\033[0m\033[1;91m]
                     \033[1;91m[\033[1;33;40m23\033[0m\033[1;91m] \033[1;97m NewsOSINT \033[1;91m[\033[1;92mNEW!\033[0m\033[1;91m]
                     \033[1;91m[\033[1;33;40m24\033[0m\033[1;91m] \033[1;97m Phone number Location \033[1;91m[\033[1;92mNEW!\033[0m\033[1;91m]
                     \033[1;91m[\033[1;33;40m25\033[0m\033[1;91m] \033[38;5;208m Tookie-OSINT \033[1;91m[\033[1;92mNEW!\033[0m\033[1;91m]
                     \033[1;91m[\033[1;33;40m26\033[0m\033[1;91m] \033[1;97m Code Analysis \033[1;91m[\033[1;92mNEW!\033[0m\033[1;91m]
                     
                     
                     \033[1;91m[\033[1;33;40mG\033[0m\033[1;91m] \033[1;97m  Go back
                     """) ##I would still add more here
    print(second_main_menu)
    second_input = input('\033[38;5;208mxosint>> \033[0m')

    
    if second_input == "26":
        def run_analyser():
            file_source = input("\033[1;91m[?]\033[1;97m Enter path to the file to analyze (eg: .py or .js file): \033[0m")
            
            if not os.path.isfile(file_source):
                print(f"\033[1;91m[!]\033[1;97m File not found: {file_source}")
                sys.exit(1)
            
            file_extension = os.path.splitext(file_source)[1]
            if file_extension == ".py":
                analyze_python_file(file_source)
            
            elif file_extension == ".js":
                analyze_javascript_file(file_source)
            
            else:
                print(f"\033[1;91m[!]\033[1;97m Unsupported file type: {file_source}")
                sys.exit(1)

        
        run_analyser()
        sys.exit(1)
        

    if second_input == "25":
        ##Add code here
        print("\033[1;91m[\033[1;33;40m!\033[0m\033[1;91m] \033[1;93mRunning Tookie-osint \033[1;91m[\033[1;92mOUR PARTNERS\033[0m\033[1;91m]")
        time.sleep(2)
        os.system("clear || cls")
        print(banner)
        print("\033[1;91m[\033[1;33;40m!\033[0m\033[1;91m] \033[1;93mLoading OUR PARTNERS.....\033[0m")
        time.sleep(0.5)
        os.system("cls || clear")
        print(tookie_banner)
        print("\033[1;91m[\033[1;33;40m!\033[0m\033[1;91m] \033[1;93mLaunching into Tookie-osint Installation....3s\033[0m")
        time.sleep(3)
        
        #tookie_dir = ""
        
        def is_termux():
            return "termux" in os.getenv("SHELL", "").lower()
        
        def clone_tookie_osint():
            #global tookie_dir
            home_dir = os.path.expanduser("~")
            tookie_dir = os.path.join(home_dir, "tookie-osint")
            
            if is_termux():
                print("Detected Termux. Setting up...")
                os.system("termux-setup-storage")
                os.system("ln -s storage/downloads Downloads")
                os.system(f"git clone https://github.com/alfredredbird/tookie-osint {tookie_dir}")
                os.chdir(tookie_dir)  
                os.system(f"pip3 install -r {os.path.join(tookie_dir, 'requirements.txt')}")
                run_tookie_osint(tookie_dir)  
            else:
                print(f"\033[1;91m[+]\033[1;97m Detected {platform.system()}. Cloning tookie-osint...\033[0m")
                if not os.path.exists(tookie_dir):
                    repo_url = "https://github.com//alfredredbird/tookie-osint.git"
                    os.system(f"git clone {repo_url} {tookie_dir}")
                    os.chdir(tookie_dir)  
                    os.system(f"pip install -r {os.path.join(tookie_dir, 'requirements.txt')}")
                    run_tookie_osint(tookie_dir)  
                else:
                    print("Tookie-OSINT already exists.")
                    run_option = input("\033[1;91m[?]\033[1;97m Do you want to run Tookie-OSINT? (Y/N): \033[0m").strip().lower()
                    
                    if run_option == "y":
                        os.chdir(tookie_dir)  
                        run_tookie_osint(tookie_dir)
                    elif run_option == "n":
                        print("\033[1;91m[+]\033[1;97m Exiting program. \033[0m")
                        sys.exit(1) # pylint: disable=unreachable
                    else:
                        print("\033[1;91m[+]\033[1;97m Invalid option. Exiting program. \033[0m")
                        sys.exit(1) # pylint: disable=unreachable
        
        def run_tookie_osint(tookie_dir):
            brib_path = os.path.join(tookie_dir, "brib.py")
            if os.path.exists(brib_path):
                if platform.system() == "Windows":
                    os.system(f"python.exe {brib_path}")
                else:
                    os.system(f"python {brib_path}")
            else:
                print("\033[1;91m[\033[1;33;40m!\033[0m\033[1;91m] \033[1;93mTookie-OSINT not found. Please clone before running \033[0m")
                sys.exit(1)

        
                    
        
        def install_tookie_osint():
            os.system("clear || cls")
            print(tookie_banner)
            tosint_main_menu = ("""
                     \033[1;91m[??] Choose an Installation
                     
                     \033[1;91m[\033[1;33;40m1\033[0m\033[1;91m] \033[1;97m Clone into Tookie-OSINT
                     \033[1;91m[\033[1;33;40m2\033[0m\033[1;91m] \033[1;97m Run Tookie-OSINT 
                     
                     \033[1;91m[\033[1;33;40mG\033[0m\033[1;91m] \033[1;97m  Go back
                     """)
            print(tosint_main_menu)
            t_option = input("\033[1;91m[\033[1;33;40m?\033[0m\033[1;91m] \033[1;93mSelect an option: \033[0m")
            if t_option == "1":
                clone_tookie_osint()
            
            elif t_option == "2":
                home_dir =os.path.expanduser("~")
                tookie_dir = os.path.join(home_dir, "tookie-osint")
                run_tookie_osint(tookie_dir)
            
            else:
                print("\033[1;91m[\033[1;33;40m!\033[0m\033[1;91m] \033[1;93mInvalid option \033[0m")
        
        install_tookie_osint()


    if second_input == "22":
        image_hunt()
        exit()
    
    elif second_input == "23":
        newsOsint()
        exit()
        
    elif second_input == "24":
        os.system("clear")
        print(banner)
        ###Menu for Two methods
        nine_main_menu = ("""
                     \033[1;91m[??] Choose a Method for Phone number Location:
                     \033[1;91m[\033[1;33;40m1\033[0m\033[1;91m] \033[1;97m Method 1 \033[1;91m[\033[1;92mLESS INFO\033[0m\033[1;91m]
                     \033[1;91m[\033[1;33;40m2\033[0m\033[1;91m] \033[1;97m Method 2 \033[1;91m[\033[1;92mMORE INFO\033[0m\033[1;91m]
                     
                     \033[1;91m[\033[1;33;40mG\033[0m\033[1;91m] \033[1;97m  Go back
                     """)
        print(nine_main_menu)
        seven_input = input('\033[38;5;208mxosint>> \033[0m')
        
        if seven_input == '1':
            phone_inf()
            exit()
            
        elif seven_input == "2":
            phone_inf2()
            exit()
        
        elif seven_input == "G" or "g":
            os.system("clear")
            os.system("sudo xosint || xosint || python3 xosint")
        
        else:
            print("\033[1;91m[\033[1;33;40m!\033[0m\033[1;91m] \033[1;93mInvalid input")
            exit()
            
    
    elif second_input == "18":
        def extract_timestamp(mail, source_code):
            try:
                timestamp = re.sub(':', '', re.search(':[0-9]{10}::', source_code.text)[0])
                return datetime.frontimestamp(int(timestamp))
            except AttributeError:
                return None
        # CHecks if its a business mail address
        
        # Protonmail account validity check
        def protonmailaccountcheck():
            invalidEmail = True
            regexEmail = r"([a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+)"
            print("\n\nYou want to know if a protonmail email is real or not?")
            while invalidEmail:
                mail = input("\033[1;91m[+]\033[1;97m Enter the email(protonmail accounts only!!): \033[0m")
                print("")
                if(re.search(regexEmail,mail)):
                    invalidEmail = False
                else:
                    print("Invalid Email")
                    invalidEmail = True
            #Check if the protonmail exist : valid / not valid
            requestProton = requests.get('https://api.protonmail.ch/pks/lookup?op=index&search='+str(mail))
            bodyResponse = requestProton.text
            protonNoExist = "info:1:0" #not valid
            protonExist = "info:1:1" #valid
            if protonNoExist in bodyResponse:
                print("\033[1;91m[!]\033[0m\033[1;97m Protonmail email is \033[0m" + f"{bcolors.FAIL}not valid{bcolors.ENDC}")
            if protonExist in bodyResponse:
                print("\033[1;91m[+]\033[0m\033[1;97m Protonmail email is \033[0m" + f"{bcolors.OKGREEN}valid{bcolors.ENDC}")
                regexPattern1 = "2048:(.*)::" #RSA 2048-bit (Older but faster)
                regexPattern2 = "4096:(.*)::" #RSA 4096-bit (Secure but slow)
                regexPattern3 = "22::(.*)::" #X25519 (Modern, fastest, secure)
            try:
                timestamp = int(re.search(regexPattern1, bodyResponse).group(1))
                dtObject = datetime.fromtimestamp(timestamp)
                print("")
                print("\033[1;91m[+]\033[0m\033[1;97m Date and time of the creation:\033[0m", dtObject)
                print("")
                print("\033[1;91m[+]\033[0m\033[1;97m Encryption : RSA 2048-bit (Older but faster)\033[0m")
            except:
                try:
                    timestamp = int(re.search(regexPattern2, bodyResponse).group(1))
                    dtObject = datetime.fromtimestamp(timestamp)
                    print("\033[1;91m[+]\033[0m\033[1;97m Date and time of the creation:\033[0m\n", dtObject)
                    print("\033[1;91m[+]\033[0m\033[1;97m Encryption : RSA 4096-bit (Secure but slow)\033[0m")
                except:
                    timestamp = int(re.search(regexPattern3, bodyResponse).group(1))
                    dtObject = datetime.fromtimestamp(timestamp)
                    print("\033[1;91m[+]\033[0m\033[1;97m Date and time of the creation:\033[0m", dtObject)
                    print("\033[1;91m[+]\033[0m\033[1;97m Encryption : X25519 (Modern, fastest, secure)\033[0m")
            #Download the public key attached to the email
            invalidResponse = True
            print("\n\033[1;91m[?]\033[0m\033[1;97mDo you want to download the public key attached to the email ?\033[0m")
            while invalidResponse:
                #Input
                responseFromUser = input("""Please enter "yes" or "no": """)
                #Text if the input is valid
                if responseFromUser == "yes":
                    invalidResponse = False
                    requestProtonPublicKey = requests.get('https://api.protonmail.ch/pks/lookup?op=get&search='+str(mail))
                    bodyResponsePublicKey = requestProtonPublicKey.text
                    print(bodyResponsePublicKey)
                elif responseFromUser == "no":
                    invalidResponse = False
                else:
                    print("Invalid Input")
                    invalidResponse = True

        #Email Search OSINT footprint
        def emailtraces():
            headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5)\
                AppleWebKit/537.36 (KHTML, like Gecko) Safari/537.36'}
            
            print("Checking Server Status\n")
            response = requests.get('https://google.com', headers)
            print(response)
            if response.status_code == 200:
                print("Status: \033[1;94mSuccess!\033[0m\n")
            elif response.status_code == 404:
                print("\033[1;91m404 Not Found, please try again!!\033[0m")
            
            searchfor = input("""\033[1;91m[+]\033[0m\033[1;94m Enter email with quotation marks eg "test@protonmail.com":  \n\033[0m""")
            
            print("\nprocessing request....\n")
            
            for result in search(searchfor, tld="com", stop=10, pause=2):
                print(result)
        
        def check_domain_name(mail):
            return mail.split("@")[1] not in ["protonmail.com", "proton.me"]


        def make_api_request(mail):
            try:
                request = requests.get("https://account.proton.me/api/users/available", 
                                       headers={
                "x-pm-appversion":"web-account@5.0.11.11",
                "x-pm-locale":"en_US"
                },
                params={
                "Name":mail,
                "ParseDomain":"1"})
                is_business_address = check_domain_name(mail) #Return code 429 = API limit exceeded
                
                if (request.status_code == 409):
                    source_code = requests.get(f'https://api.protonmail.ch/pks/lookup?op=index&search={mail}')
                    creation_date = extract_timestamp(mail, source_code)
                    print("\033[1m\n\nProtonMail Account is VALID! Creation date: " + str(creation_date) + " \033[0m\U0001F4A5")
                    return True
                elif(request.status_code == 429):
                    print("\u001b[31m\n\nAPI requests limit exceeded...")
                
                elif is_business_address:
                    print("\u001b[33m\nProtonmail API does not handle business emails, ""but you can get account creation date + PGP Key")
                    return True
                else:
                    print("\u001b[31m\n\nProtonMail account is NOT VALID")
                    return False
            except:
                print("Error when requesting the API")
                return False

        
        
        #Get protonmail user PGP key
        def pgpkeyinformation():
            choice = input("""
                 View PGP key in Terminal  [T] or Download Key [D]: """)
            
            if choice == "T" or "t":
                pgpkeyview()
            if choice == "D" or "d":
                pgpkeydirectdownload()
                
        def pgpkeydirectdownload():
            email_query = input("\nEnter target email to download PGP key: ")
            import webbrowser
            alink = 'https://api/protonmail.ch/pks/lookup?op=get&search='+email_query
            new = 2
            webbrowser.open(alink, new=new)
            
        #extract the key
        def extract_key(source_code):
            regex = ':[0-9]{2,4}:(.*)::'
            
            try:
                return re.search(regex, source_code.text)[0].split(":")[1]
            except AttributeError:
                return None
        
        # view pgp key within terminal
        def pgpkeyview():
            invalidEmail = True
            regexEmail = r"([a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+)"
            
            print("\nInput protonmail user email to get user's PGP key\n")
            while invalidEmail:
                mail = input("Type in protonmail: ")
                
                if (re.search(regexEmail, mail)):
                    invalidEmail = False
                else:
                    print("Protonmail user doesnt exists\n")
                    invalidEmail = True
            if(make_api_request(mail)):
                source_code = request.get("https://api.protonmail.ch/pks/lookup?op=index&search=" + mail)
                if("info:1.0" in source_code.text):
                    print("Cant get the PGP information")
                else:
                    timestamp = extract_timestamp(mail, source_code)
                    key = extract_key(source_code)
                    
                    print("PGP Key Date and Creation Time: ", str(timestamp))
                    
                    if(key != "22"):
                        print("Encryption Standard: RSA " + key + "-bit")
                    else:
                        print("Encryption standard: ECC Curve")
                    
                    invalidResponse = True
                    
                    print("Get user PGP Key?: ")
                    while invalidResponse:
                        responseFromUser = input("""[Y] or [N]: """)
                        
                        if responseFromUser == "Y":
                            invalidResponse = False
                            requestProtonPublicKey = request.get("https://api.protonmail.ch/pks/lookup?op=index&search=" + str(mail))
                            
                            bodyResponsePublicKey = requestProtonPublicKey.text
                            print(bodyResponsePublicKey)
                        elif responseFromUser == "N":
                            invalidResponse
                        else:
                            print("Input not valid")
                            invalidResponse = True
        #CHeck user Ip belongs to protonVPN user       
        def protonvpnipsearch():
            while True:
                try:
                    ip = ipaddress.ip_address(input('Enter IP Address: '))
                    
                    break
                except ValueError:
                    continue
            requestProton_vpn = requests.get("https://api.protonmail.ch/vpn/logicals")
            bodyResponse = requestProton_vpn.text
            if str(ip) in bodyResponse:
                print("\033[1;92m[+] This Ip is currently associated to protonVPN \033[0m")
            else:
                print("\033[1;91m[!] This Ip is not associated with any protonVPN Account\033[0m")
                
        def checkProtonAPIStatut():
            requestProton_mail_statut = requests.get('https://api.protonmail.ch/pks/lookup?op=index&search=test@protonmail.com')
            if requestProton_mail_statut.status_code == 200:
                print("Protonmail API is " + f"{bcolors.BOLD}ONLINE{bcolors.ENDC}")
            else:
                print("Protonmail API is " + f"{bcolors.BOLD}OFFLINE{bcolors.ENDC}")
                requestProton_vpn_statut = requests.get('https://api.protonmail.ch/vpn/logicals')
                if requestProton_vpn_statut.status_code == 2:
                    print("Protonmail VPN is " + f"{bcolors.BOLD}ONLINE{bcolors.ENDC}")
                else:
                    print("Protonmail VPN is " + f"{bcolors.BOLD}OFFLINE{bcolors.ENDC}")

        
        proton_osint = ("""
                      \033[1;91m[\033[1;33;40m1\033[0m\033[1;91m] \033[1;97m Protonmail Account Check
                      \033[1;91m[\033[1;33;40m2\033[0m\033[1;91m] \033[1;97m Email Traces
                      \033[1;91m[\033[1;33;40m3\033[0m\033[1;91m] \033[1;97m ProtonVPN IP Search
                      \033[1;91m[\033[1;33;40m4\033[0m\033[1;91m] \033[1;97m PGP Key Information
                      \033[1;91m[\033[1;33;40mG\033[0m\033[1;91m] \033[1;97m Go back
                      """)
        print(proton_osint)
        b_osint = input('\033[1;91m[+]\033[0m\033[1;94m Make your choice: \033[0m')
        checkProtonAPIStatut()
        if b_osint == "1":
            ##checkprotonmailapistatus()
            protonmailaccountcheck()
      
        elif b_osint == "2":
            emailtraces()
        elif b_osint == "3":
            protonvpnipsearch()
        elif b_osint == "4":
            pgpkeyinformation()
        elif b_osint == "G" or "g":
            os.system("cd $HOME")
            os.system("sudo xosint || xosint || python xosint")
        else:
            print("\033[1;91m[!]\033[0m\033[1;97mInvalid Command..exiting\033[0m")
            time.sleep(0.0001)
            exit()
    elif second_input == "19":
        open_terminal = ("""
                      \033[1;91m[\033[1;33;40m1\033[0m\033[1;91m] \033[1;97m View in CLI
                      \033[1;91m[\033[1;33;40m2\033[0m\033[1;91m] \033[1;97m View in GUI
                      \033[1;91m[\033[1;33;40mG\033[0m\033[1;91m] \033[1;97m Go back
                      """)
        print(open_terminal)
        c_input = input('\033[1;91m[+]\033[0m\033[1;94m Make your choice: \033[0m')
        
        if c_input == "1":
            #import vininfo
            import click
            from vininfo import Vin
            num = input("\033[1;91m[+]\033[1;97m Enter VIN Number: \033[0m")
            def check(num):
                if Vin(num).verify_checksum():
                    click.secho('Checksum is valid', fg='green')
                else:
                    click.secho('Checksum is not valid', fg='red', err=True)
                    sys.exit(1)
            check(num)
            vin = Vin(num)
            
            print("")
            click.secho('Basic:')
            print("\033[1;97m[+] Country: \033[0m" + vin.country)
            print()
            time.sleep(0.5)
            print('\033[1;97m[+] Manufacturer: \033[0m' + vin.manufacturer)
            time.sleep(0.5)
            print("\033[1;97m[+] Region: \033[0m" + vin.region)
            time.sleep(0.5)
            print("\033[1;97m[+] Serial: \033[0m" + vin.vis)
            print()
            time.sleep(0.5)
            print('\033[1;97m[+] Plant: \033[0m' + vin.vds)
            time.sleep(0.5)
            print("\033[1;97m[+] Model: \033[0m" + vin.wmi)
            time.sleep(0.5)
            print("")
            click.secho('Year Model')
            print(vin.years)
            print()
            
         
        elif c_input == "2":
            from tkinter import *
            from tkinter import messagebox
            from vininfo import Vin
            import requests
            
            root = Tk()
            
            root.title("X-osint VIN Number Extractor")
            
            #Create a label
            
            lbl_vin_number = Label(root, text="VIN Number:")
            
            lbl_vin_number.grid(row=0, column=0, padx=5, pady=5)
            
            #Create an entry box
            
            ent_vin_number = Entry(root)
            ent_vin_number.grid(row=0, column=1, padx=5, pady=5)
            #Create a button
            btn_extract = Button(root, text="Extract", command=lambda: extract_data(ent_vin_number.get()))
            
            btn_extract.grid(row=1, column=0, padx=5, pady=5, columnspan=2)
            
            def extract_data(vin_number):
                if vin_number == "":
                    messagebox.showinfo("Error", "Please enter a valid VIN number!")
                else:
                    try:
                        vin_url = "https://vpic.nhtsa.dot.gov/api/vehicles/DecodeVINValuesExtended/" + vin_number + "?format=json"
                        vin_data = requests.get(vin_url).json()
                        make = vin_data['Results'][0]['Make']
                        model = vin_data['Results'][0]['Model']
                        year = vin_data['Results'][0]['ModelYear']
                        #country = vin_data['Results'][0]['Country']
                        messagebox.showinfo("VIN Information", "Make: " + make + "\nModel: " + model + "\nYear: " + year)
                    except:
                        messagebox.showinfo("Error", "Invalid VIN number!")
                        
                        #Run the main loop
            root.mainloop()        
                    
            #print("Still in development")
        
        
        elif c_input == "G" or "g":
            os.system("cd $HOME")
            os.system("sudo xosint || xosint || python3 xosint")
        else:
            print("\033[1;91m[!]\033[0m\033[1;97mInvalid Command..exiting\033[0m")
            time.sleep(0.0001)
            exit()
    elif second_input == "20":
        import requests
        import find_github_email
        
        username = input("\033[1;91m[+]\033[0m\033[1;97m Enter the Github Username: \033[0m")
        url_link = f'https://api.github.com/users/{username}'
        url_link2 = f'https://api.github.com/users/{username}/repos'
        
        response = requests.get(url_link)
        response1 = requests.get(url_link2)
        
        
        if response.status_code == 200:
            user_data = response.json()
            repos = response1.json()
            
            print(f"\n\033[1;96m Name: \033[0m{user_data['name']}\n")
            print(f"\033[1;96m Location: \033[0m{user_data['location']}\n")
            print(f"\033[1;96m Followers: \033[0m{user_data['followers']}\n")
            print(f"\033[1;96m Following: \033[0m{user_data['following']}\n")
            print(f"\033[1;96m Email Address: \033[0m{user_data['email']}\n")
            print(f"\033[1;96m Number of Repos: \033[0m{len(repos)}\n")
            
            response2 = find_github_email.find(username)
            print(f"\n{response2}\n")
        else:
            print("\n\033[1;97m[!]\033[0m\033[1;91m Error!!!, Couldnt get details, too many requests, \n\033[1;97m Try again after some time!.. \033[0m\n")
            time.sleep(2)
            sys.exit(1)
        
    elif second_input == "21":
        try:
            license_plate = input("\033[1;91m[+]\033[0m\033[1;97m License plate(US License plates ONLY FOR NOW): \033[0m")
            
            lplate = license_plate.upper()
            plate = "".join(license_plate.split(" "))
            
            state = input("\033[1;91m[+]\033[1;97m State (Eg If its Alabama type 'AL'): \033[0m")
            state = state.upper()
            
            print("")
            print("\n\033[1;93mSearching.....\033[0m")
            URL = "https://findbyplate.com/US/"+state+"/"+plate+"/"
            
            page = requests.get(URL, verify=True)
            soupPage = bs(page.content, 'html.parser')
            mayresults = soupPage.find("h2", {"class": "vehicle-modal"})
            mayraw = mayresults.prettify().split("\n")[1]
            may = mayraw[1:len(mayraw)]
            
            year = may[0:4]
            model = may[5:len(may)]
            
            countryResults = soupPage.find("div", {"data-title": "PlantCountry"})
            countryResultsraw = countryResults.prettify().split("\n")[1]
            
            country = countryResultsraw[1:len(countryResultsraw)]
            countryResults = soupPage.find("div", {"data-title": "PlantCity"})
            
            countryResultsraw = countryResults.prettify().split("\n")[1]
            city = countryResultsraw[1:len(countryResultsraw)]
            
            vtypeResults = soupPage.find("div", {"data-title": "VehicleType"})
            
            vtyperaw = vtypeResults.prettify().split("\n")[1]
            type = vtyperaw[1:len(vtyperaw)]
            
            location = city + ", " + country
            
            print("\033[1;92mDone!\033[0m\n")
            
            print("\033[1mModel:\033[0m              \033[1mYear:\033[0m" + " " * 7 + "\033[1mVehicle Type:\033[0m")
            print(model + " " * (20 - len(model)) + year + "        " + type)
            
            print("\n\033[1mPlate Number:\033[0m       \033[1mState:\033[0m      \033[1mPlant Location:\033[0m")
            print(lplate + " " * (20 - len(lplate)) + state + "          " + location)

        except KeyboardInterrupt:
            print("\n\033[91mExiting...\033[0m")
        
        except AttributeError:
            print("\033[1;91mOops!! Vehicle Not Found\033[0m")
        except:
            print("\033[91mError Found, please contact developer\033[0m")
            raise;

        
    
    elif second_input == "G" or "g":
        os.system("cd $HOME")
        os.system("sudo xosint || xosint || python xosint")
    
    else:
        print("\033[91mInvalid Option\033[0m")
        exit()

elif option == "99":
	update()
elif option == "00":
	print()
	exit
elif option == "100":
	print(about)
	exit


### ADD NEXT MAIN MENU TO IT
	

else:
	print()
	print("[*] Invalid Input..try again....")
	sleep(0.9)
	exit()
#END OF SCRIPT
